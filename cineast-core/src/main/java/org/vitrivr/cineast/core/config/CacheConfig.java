package org.vitrivr.cineast.core.config;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.vitrivr.cineast.core.data.raw.CachedDataFactory;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.UUID;

public final class CacheConfig {
	public enum Policy{
		FORCE_DISK_CACHE, //cache to disk even if newInMemoryMultiImage is requested
		DISK_CACHE, //cache to disk unless newInMemoryMultiImage is requested
		AUTOMATIC, //keep in memory as long as threshold is not exceeded, makes exceptions for images not generated by the video decoder
		AVOID_CACHE //avoids cache until hard limit is reached
	}

	private static final Logger LOGGER = LogManager.getLogger();

	private Policy cachingPolicy =  Policy.AUTOMATIC;
	private long softMinMemory = 3246391296L;
	private long hardMinMemory = 2147483648L;
	private Path cacheLocation = Paths.get(".");
	private final UUID uuid = UUID.randomUUID();
	private CachedDataFactory factory;

	public CacheConfig() {}

	/**
	 *
	 * @param softMemoryLimit Soft memory limit for in-memory frame cache in MB
	 * @param hardMemoryLimit Hard memory limit for in-memory frame cache in MB
	 * @param cachePolicy Caching Policy
	 * @param cacheLocation the file system location of the disk cache
	 * @throws IllegalArgumentException in case any of the memory limits is negative
	 * @throws NullPointerException in case the cachePolicy or cacheLocation is null
	 * @throws SecurityException in case access to cacheLocation is not permitted
	 */
	@JsonCreator
	public CacheConfig(
		@JsonProperty(value = "softMemoryLimit", required = true, defaultValue = "3246391296") int softMemoryLimit,
		@JsonProperty(value = "hardMemoryLimit", required = true, defaultValue = "2147483648") int hardMemoryLimit,
		@JsonProperty(value = "cachePolicy", required = false, defaultValue = "AUTOMATIC") String cachePolicy,
		@JsonProperty(value = "cacheLocation", required = false, defaultValue = ".") String cacheLocation){

		if(softMemoryLimit < 0){
			throw new IllegalArgumentException("Memory limit must me positive");
		}
		if(hardMemoryLimit < 0){
			throw new IllegalArgumentException("Memory limit must me positive");
		}
		if (cachePolicy == null) {
			cachePolicy = "AUTOMATIC";
		}
		if (cacheLocation == null) {
			cacheLocation = ".";
		}

		final Path location = Paths.get(cacheLocation);
		if (!Files.exists(location)) {
			try {
				Files.createDirectories(location);
				this.cacheLocation = location;
			} catch (IOException e) {
				this.cacheLocation = Paths.get(".");
				LOGGER.warn("Specified cache location ({}) could not be created! Fallback to default location: {}", location.toAbsolutePath().toString(), this.cacheLocation.toAbsolutePath().toString());
			}
		} else if (!Files.isDirectory(location)) {
			this.cacheLocation = Paths.get(".");
			LOGGER.warn("Specified cache location ({}) could not be created! Fallback to default location: {}", location.toAbsolutePath().toString(), this.cacheLocation.toAbsolutePath().toString());
		} else {
			this.cacheLocation = location;
		}
		this.softMinMemory = 1024L * 1024L * softMemoryLimit;
		this.hardMinMemory = 1024L * 1024L * hardMemoryLimit;
		this.cachingPolicy = Policy.valueOf(cachePolicy);
	}
	
	/**
	 */
	@JsonProperty
	public final long getSoftMinMemory(){
		return this.softMinMemory;
	}
	public void setSoftMemoryLimit(long softMinMemory) {
		if(softMinMemory < 0){
			throw new IllegalArgumentException("Memory limit must me positive");
		}
		this.softMinMemory = 1024L * 1024L * softMinMemory;
	}
	
	/**
	 * @return the hard memory limit in bytes
	 */
	@JsonProperty
	public final long getHardMinMemory(){
		return this.hardMinMemory;
	}
	public void setHardMemoryLimit(long hardMinMemory) {
		if(hardMinMemory < 0){
			throw new IllegalArgumentException("Memorylimit must me positive");
		}
		this.hardMinMemory = 1024L * 1024L * hardMinMemory;
	}

	/**
	 * @return the caching policy
	 */
	@JsonProperty
	public final Policy getCachingPolicy(){
		return this.cachingPolicy;
	}
	public void setCachingPolicy(Policy cachingPolicy) {
		if(cachingPolicy == null){
			throw new NullPointerException("CachePolicy cannot be null");
		}
		this.cachingPolicy = cachingPolicy;
	}

	/**
	 * @return the file system location of the cache
	 */
	@JsonProperty
	public final Path getCacheLocation(){
		return this.cacheLocation;
	}
	public void setCacheLocation(Path cacheLocation) {
		if(cacheLocation == null){
			throw new NullPointerException("CacheLocation cannot be null");
		}
		this.cacheLocation = cacheLocation;
	}

	/**
	 * Returns the UUID of this {@link CacheConfig}.
	 *
	 * @return UUID of this {@link CacheConfig}.
	 */
	public String getUUID() {
		return this.uuid.toString();
	}

	/**
	 * A simple heuristic to determine whether an object of the given size should be cached or kept in-memory.
	 *
	 * @param size Size of the object in bytes.
	 * @return True if object should be kept in memory, false otherwise.
	 */
	public boolean keepInMemory(int size) {
		switch (this.cachingPolicy) {
			case FORCE_DISK_CACHE:
				return false;
			case AUTOMATIC:
				return size <= this.softMinMemory;
			case AVOID_CACHE:
				return size <= this.hardMinMemory;
			default:
				return true;
		}
	}

	/**
	 * Returns and optionally creates the shared {@link CachedDataFactory} instance created by this {@link CacheConfig}.
	 *
	 * @return Shared {@link CachedDataFactory}.
	 */
	public synchronized CachedDataFactory sharedCachedDataFactory() {
		if (this.factory == null) {
			this.factory = new CachedDataFactory(this);
		}
		return this.factory;
	}

	@Override
	public String toString(){
		return "\"cache\" : { \"cachePolicy\" : \"" +
				this.cachingPolicy.toString() +
				"\", \"softMemoryLimit\" : " +
				this.softMinMemory / 1024L / 1024L +
				"\", \"hardMemoryLimit\" : " +
				this.hardMinMemory / 1024L / 1024L +
				", \"cacheLocation\" : \"" +
				this.cacheLocation.toString() +
				"\" }";
	}
	
}
