package org.vitrivr.cineast.core.config;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.vitrivr.cineast.core.data.MultiImageFactory;

import java.io.File;
import java.util.UUID;

public final class ImageCacheConfig {
	public enum Policy{
		FORCE_DISK_CACHE, //cache to disk even if newInMemoryMultiImage is requested
		DISK_CACHE, //cache to disk unless newInMemoryMultiImage is requested
		AUTOMATIC, //keep in memory as long as threshold is not exceeded, makes exceptions for images not generated by the video decoder
		AVOID_CACHE //avoids cache until hard limit is reached
	}

	private static final Logger LOGGER = LogManager.getLogger();

	private Policy cachingPolicy =  Policy.AUTOMATIC;
	private long softMinMemory = 3246391296L;
	private long hardMinMemory = 2147483648L;
	private File cacheLocation = new File(".");
	private final UUID uuid = UUID.randomUUID();
	private MultiImageFactory factory;

	public ImageCacheConfig() {}

	/**
	 *
	 * @param softMemoryLimit Soft memory limit for in-memory frame cache in MB
	 * @param hardMemoryLimit Hard memory limit for in-memory frame cache in MB
	 * @param cachePolicy Caching Policy
	 * @param cacheLocation the file system location of the disk cache
	 * @throws IllegalArgumentException in case any of the memory limits is negative
	 * @throws NullPointerException in case the cachePolicy or cacheLocation is null
	 * @throws SecurityException in case access to cacheLocation is not permitted
	 */
	@JsonCreator
	public ImageCacheConfig(
		@JsonProperty(value = "softMemoryLimit", required = true, defaultValue = "3246391296") int softMemoryLimit,
		@JsonProperty(value = "hardMemoryLimit", required = true, defaultValue = "2147483648") int hardMemoryLimit,
		@JsonProperty(value = "cachePolicy", required = false, defaultValue = "AUTOMATIC") String cachePolicy,
		@JsonProperty(value = "cacheLocation", required = false, defaultValue = ".") String cacheLocation){

		if(softMemoryLimit < 0){
			throw new IllegalArgumentException("Memory limit must me positive");
		}
		if(hardMemoryLimit < 0){
			throw new IllegalArgumentException("Memory limit must me positive");
		}
		if (cachePolicy == null) {
			cachePolicy = "AUTOMATIC";
		}
		if (cacheLocation == null) {
			cacheLocation = ".";
		}

		final File location = new File(cacheLocation);
		if(!(location.exists() && location.isDirectory()) || location.mkdirs()){
			this.cacheLocation = new File(".");
			LOGGER.warn("Specified cache location ({}) is invalid, using default location: {}", location.getAbsolutePath(), this.cacheLocation.getAbsolutePath());
		}else{
			this.cacheLocation = location;
		}
		this.softMinMemory = 1024L * 1024L * softMemoryLimit;
		this.hardMinMemory = 1024L * 1024L * hardMemoryLimit;
		this.cachingPolicy = Policy.valueOf(cachePolicy);
	}
	
	/**
	 * @return the soft memory limit in bytes
	 */
	@JsonProperty
	public final long getSoftMinMemory(){
		return this.softMinMemory;
	}
	public void setSoftMemoryLimit(long softMinMemory) {
		if(softMinMemory < 0){
			throw new IllegalArgumentException("Memory limit must me positive");
		}
		this.softMinMemory = 1024L * 1024L * softMinMemory;
	}
	
	/**
	 * @return the hard memory limit in bytes
	 */
	@JsonProperty
	public final long getHardMinMemory(){
		return this.hardMinMemory;
	}
	public void setHardMemoryLimit(long hardMinMemory) {
		if(hardMinMemory < 0){
			throw new IllegalArgumentException("Memorylimit must me positive");
		}
		this.hardMinMemory = 1024L * 1024L * hardMinMemory;
	}

	/**
	 * @return the caching policy
	 */
	@JsonProperty
	public final Policy getCachingPolicy(){
		return this.cachingPolicy;
	}
	public void setCachingPolicy(Policy cachingPolicy) {
		if(cachingPolicy == null){
			throw new NullPointerException("CachePolicy cannot be null");
		}
		this.cachingPolicy = cachingPolicy;
	}

	/**
	 * @return the file system location of the cache
	 */
	@JsonProperty
	public final File getCacheLocation(){
		return this.cacheLocation;
	}
	public void setCacheLocation(File cacheLocation) {
		if(cacheLocation == null){
			throw new NullPointerException("CacheLocation cannot be null");
		}
		this.cacheLocation = cacheLocation;
	}

	/**
	 * Returns the UUID of this {@link ImageCacheConfig}.
	 *
	 * @return UUID of this {@link ImageCacheConfig}.
	 */
	public String getUUID() {
		return this.uuid.toString();
	}

	/**
	 * Returns and optionally creates the shared {@link MultiImageFactory} created by this {@link ImageCacheConfig}.
	 *
	 * @return Shared {@link MultiImageFactory}.
	 */
	public synchronized MultiImageFactory sharedMultiImageFactory() {
		if (this.factory == null) {
			this.factory = new MultiImageFactory(this);
		}
		return this.factory;
	}

	@Override
	public String toString(){
		return "\"cache\" : { \"cachePolicy\" : \"" +
				this.cachingPolicy.toString() +
				"\", \"softMemoryLimit\" : " +
				this.softMinMemory / 1024L / 1024L +
				"\", \"hardMemoryLimit\" : " +
				this.hardMinMemory / 1024L / 1024L +
				", \"cacheLocation\" : \"" +
				this.cacheLocation.getAbsolutePath() +
				"\" }";
	}
	
}
